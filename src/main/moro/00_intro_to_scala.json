{
  "name" : "Introduction to Scala",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Note by Sebastian:\nIn particular, we should teach them things like\n\n* groupBy\n* maxBy\n* of course map/filter etc.\n* mapValues \n* case classes\n* mutable data structures\nSection Name",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "overview",
      "extraFields" : { }
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Scala Crash Course\n\nThis short Scala crash course is based on [Scala School by Twitter](https://twitter.github.io/scala_school/).\n\nWe chose Scala as the language for the course (as well as the language we develop our systems in) because of several reasons, some of which are:\n\n* Increasingly used in NLP and ML, but don't take our word for it, take a look at the code of some of the world's leading labs: [UCL Machine Reading group](https://github.com/uclmr/) :), [Berkeley NLP Group](http://nlp.cs.berkeley.edu/) and [another interesting ML project at UC Berkeley](http://bid2.berkeley.edu/bid-data-project/) , [University of Washington](http://knowitall.github.io/openie/), [Allen Institute for Artificial Intelligence](https://github.com/allenai), etc.\n* Expressive - first class functions, closures  \n* Concise - type inference, on the quest to eliminate boilerplate code\n* Java interoperability - can reuse java libraries!\n* bear in mind that Scala is not Java on steroids :) it is different due to it being an object-oriented functional programming language (cannot stress the functional part enough)",
      "extraFields" : { }
    }
  }, {
    "id" : 3,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "installing",
      "extraFields" : { }
    }
  }, {
    "id" : 4,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Installing scala\nIn order to install Scala, please follow [these instructions](http://www.scala-lang.org/download/install.html).\n\nStarting the interpreter\n\nProgramming in IntelliJ",
      "extraFields" : { }
    }
  }, {
    "id" : 5,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "basics",
      "extraFields" : { }
    }
  }, {
    "id" : 6,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "# Scala basics\n\nThis part of the tutorial concernes the basics of Scala you will need in order to understand this book and be able to code your assignments.\n",
      "extraFields" : { }
    }
  }, {
    "id" : 7,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "expressions",
      "extraFields" : { }
    }
  }, {
    "id" : 8,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Expressions\n\nAlmost everything in Scala is an expression, for example, numerical calulations:",
      "extraFields" : { }
    }
  }, {
    "id" : 9,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "1.5 + 1.21828189",
      "extraFields" : {
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 10,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "...string operations:",
      "extraFields" : { }
    }
  }, {
    "id" : 11,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\"Soft\" + \" \" + \"kitty,\" + \" warm\".+(\" kitty\")",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\"]"
      }
    }
  }, {
    "id" : 12,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "...or logical expressions",
      "extraFields" : { }
    }
  }, {
    "id" : 13,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "if (2 > 5 || 5 > 2) 7 else 4 ",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\"]"
      }
    }
  }, {
    "id" : 14,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Scala suports values and variables. Values are technically constants, and they cannot be changed (they are immutable), as opposed to variables which can (are mutable). Try removing the commented piece of code to verify that:",
      "extraFields" : { }
    }
  }, {
    "id" : 15,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val value = \"I cannot be changed! Really!\"\n// value = \"But surely, this is not true?!\"\nvalue",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \"]"
      }
    }
  }, {
    "id" : 16,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "var variable = \"However, I can!\"\nvariable = \"See? I can change!\"\nvariable",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\"]"
      }
    }
  }, {
    "id" : 17,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "NEED TO RE-THINK THIS PART....next: creating a list, applying functions \n\nafter that, the rest",
      "extraFields" : { }
    }
  }, {
    "id" : 18,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "functions",
      "extraFields" : { }
    }
  }, {
    "id" : 19,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Functions\n\n* Every function is an object\n* Specify type signature\n* Need to provide type for function parameters (automatically inferred, if possible)\n* Can be stored in variables, passed as parameters\n* Can create anonymous functions\n<br><br>",
      "extraFields" : { }
    }
  }, {
    "id" : 20,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def depluralizer(word: String) =\n   if (word.takeRight(4) == \"sses\" || word.takeRight(3) == \"ies\" )\n     word.stripSuffix(\"es\")\n   else if (word.takeRight(2) == \"ss\")\n     word\n   else\n     word.stripSuffix(\"s\")\ndef exclamator(word: String) = word + \"!\"\nval removeIng = (word: String) => word.stripSuffix(\"ing\")\ndepluralizer(\"businesses\")",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\"]"
      }
    }
  }, {
    "id" : 21,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "morefunctions",
      "extraFields" : { }
    }
  }, {
    "id" : 22,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## More functions...\n* Partial application\n   * \"Fixes\" a subset of the input domain\n* Currying\n   * Multiple argument function into a chain of single argument functions\n<br><br>",
      "extraFields" : { }
    }
  }, {
    "id" : 23,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "// partial function application\ndef addSuffix(stem: String, suffix: String): String =\n  stem + suffix\nval addIng = addSuffix(_:String, \"ing\")\naddIng(\"Learn\")\n// currying\ndef addWords(w1: String)(w2: String)(w3: String): String =\n  w1 + \" \" + w2 + \" \" + w3\nval curried = addWords _\nval soft = curried(\"soft\")\nval kitty = soft(\"kitty\")\nkitty(\"warm\")",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\"]"
      }
    }
  }, {
    "id" : 24,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "andmorefunctions",
      "extraFields" : { }
    }
  }, {
    "id" : 25,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## ...and more functions\n* Variable length arguments\n<br><br>",
      "extraFields" : { }
    }
  }, {
    "id" : 26,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def concatenateAll(joiningSym: String, args: String*) = {\n args.foldLeft(\"\")((x: String, y: String) => x + joiningSym + y)\n}\nconcatenateAll(\"+\",\"soft\", \"kitty\", \"warm\", \"kitty\")",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\"]"
      }
    }
  }, {
    "id" : 27,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "patternmatching",
      "extraFields" : { }
    }
  }, {
    "id" : 28,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Pattern Matching\n* Brutally useful!\n<br><br>",
      "extraFields" : { }
    }
  }, {
    "id" : 29,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def step1stemmer(word: String): String = {\n word match {\n   case i if (i.takeRight(1)==\"s\") => depluralizer(i)\n   case i if (i.takeRight(3)==\"ing\") => removeIng(i)\n   case i if (i.takeRight(2)==\"ed\") => word.stripSuffix(\"ed\")\n }\n}\nstep1stemmer(\"learning\")",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\"]"
      }
    }
  }, {
    "id" : 30,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "pm2",
      "extraFields" : { }
    }
  }, {
    "id" : 31,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Pattern matching cntd.\n* Create functions\n<br><br>",
      "extraFields" : { }
    }
  }, {
    "id" : 32,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def factorial(n: Int): Int = {\n n match {\n  case 0 | 1 => 1\n  case x => x * factorial(n-1)\n }\n}\nfactorial(5)",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\"]"
      }
    }
  }, {
    "id" : 33,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "pm3",
      "extraFields" : { }
    }
  }, {
    "id" : 34,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Pattern matching cntd.\n* Checking for types\n<br><br>",
      "extraFields" : { }
    }
  }, {
    "id" : 35,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def parseArgument(arg: String, value: Any): String =\n  (arg, value) match {\n case (\"-x\", x) => \"-x\" + x\n case (\"-v\", v: Int) if (v<3) => \"-v < 3\"\n case (\"-v\", weird_value) => \"-v weird value!!\"\n case unk => \"An unknown argument: \" + unk\n}\nparseArgument(\"-v\", 0.5)",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\"]"
      }
    }
  }, {
    "id" : 36,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "pm4",
      "extraFields" : { }
    }
  }, {
    "id" : 37,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Pattern matching with Case classes\n* Matching on class members\n* Case classes!\n   * Store and match on the contents of a class\n   * Construction without \"new\"\n<br><br>",
      "extraFields" : { }
    }
  }, {
    "id" : 38,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "abstract class Node\ncase class Split(left: Node, right: Node) extends Node\ncase class Leaf(value: Int) extends Node\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\n\ndef sum(tree: Node): Int = tree match {\n case Leaf(n) => n\n case Split(left, right) => sum(left) + sum(right)\n}\n\nsum(tree)",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\"]"
      }
    }
  }, {
    "id" : 39,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "exceptions",
      "extraFields" : { }
    }
  }, {
    "id" : 40,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Exceptions\n* Try-catch-final + pattern matching\n<br><br>",
      "extraFields" : { }
    }
  }, {
    "id" : 41,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "var ok: Boolean = true\nval computation: Double = try {\n 1 / 0\n} catch {\ncase e: ArithmeticException => {ok = false; Double.NaN}\n} finally {\nok = false\n}\n\n\"computation=%f, ok=%s\".format(computation,ok)",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\"]"
      }
    }
  }, {
    "id" : 42,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "placeholder",
      "extraFields" : { }
    }
  }, {
    "id" : 43,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "# ???",
      "extraFields" : { }
    }
  }, {
    "id" : 44,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def ??? : Nothing = throw new NotImplementedError\n\n//todo, but already compiles\ndef answerToLifeTheUniverseAndEverything() = ???\ndef question(s: String) = s match {\n  case \"the answer to life the universe and everything\" =>\n    answerToLifeTheUniverseAndEverything()\n  case _ => ???\n}\n\n//already done\ndef answerOnePlusOne() = 2\nanswerOnePlusOne()",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\"]"
      }
    }
  }, {
    "id" : 45,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "collections",
      "extraFields" : { }
    }
  }, {
    "id" : 46,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "# Collections\n",
      "extraFields" : { }
    }
  }, {
    "id" : 47,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "lists",
      "extraFields" : { }
    }
  }, {
    "id" : 48,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## LISTS",
      "extraFields" : { }
    }
  }, {
    "id" : 49,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val tokens1 = List(\"All\", \"work\", \"and\", \"no\", \"play\", \"makes\",\n                   \"Jack\", \"a\", \"dull\", \"boy\", \".\")\ntokens1\ntokens1.head\ntokens1.tail\n\"Jack Torrance: \" :: tokens1",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\"]"
      }
    }
  }, {
    "id" : 50,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "lists2",
      "extraFields" : { }
    }
  }, {
    "id" : 51,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val tokens2 = List(\"Jack\", \"!\", \"What\", \"...\", \"are\", \"you\", \"?\")\ntokens2\nval tokens3 = tokens1 ++ tokens2\ntokens3\ntokens3.distinct",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\"]"
      }
    }
  }, {
    "id" : 52,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "sets",
      "extraFields" : { }
    }
  }, {
    "id" : 53,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Sets\n",
      "extraFields" : { }
    }
  }, {
    "id" : 54,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val words1 = Set(\"Do\", \",\", \"or\", \"do\", \"not\", \".\",\n                 \"There\", \"is\", \"no\", \"try\", \".\")\nwords1\n\nval words2 = Set(\"A\", \"martini\", \".\",\n                 \"Shaken\", \",\", \"not\", \"stirred\", \".\")\nwords1 union words2\n\nwords1 intersect words2\n\nwords1 diff words2",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\"]"
      }
    }
  }, {
    "id" : 55,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "maps",
      "extraFields" : { }
    }
  }, {
    "id" : 56,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Maps",
      "extraFields" : { }
    }
  }, {
    "id" : 57,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val lemmas = Map(\"saving\" -> \"save\", \"tokens\" -> \"token\",\n                 \"token\" -> \"token\", \"occurring\" -> \"occur\")\nlemmas\nlemmas(\"tokens\")\nlemmas.keySet",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\"]"
      }
    }
  }, {
    "id" : 58,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "tuples",
      "extraFields" : { }
    }
  }, {
    "id" : 59,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Tuples",
      "extraFields" : { }
    }
  }, {
    "id" : 60,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val wordCount = (\"like\", 2)\nwordCount._2\nwordCount._1\n\"like\" -> 2 == (\"like\", 2)",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\"]"
      }
    }
  }, {
    "id" : 61,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "option",
      "extraFields" : { }
    }
  }, {
    "id" : 62,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Option",
      "extraFields" : { }
    }
  }, {
    "id" : 63,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val lemmaOpt1 = lemmas.get(\"tokens\")\nlemmaOpt1\nlemmaOpt1.get\n\nval lemmaOpt2 = lemmas.get(\"Open the pod bay doors, HAL.\")\nlemmaOpt2\n\nif (lemmaOpt2.isDefined)\n  lemmaOpt2.get\nelse\n  \"I'm sorry, Dave.\"\n  \nlemmaOpt2.getOrElse(\"I'm afraid I can't do that.\").toString",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\"]"
      }
    }
  }, {
    "id" : 64,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "collections",
      "extraFields" : { }
    }
  }, {
    "id" : 65,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## Methods on Collections",
      "extraFields" : { }
    }
  }, {
    "id" : 66,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "map",
      "extraFields" : { }
    }
  }, {
    "id" : 67,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## map",
      "extraFields" : { }
    }
  }, {
    "id" : 68,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val sentences = List(\"Daisy, Daisy, give me your answer do.\",\n                     \"I'm half crazy all for the love of you.\")\n//sentences.head.toCharArray.map(c => c.toLower).mkString",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\"]"
      }
    }
  }, {
    "id" : 69,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "  def dyingHAL(string: String) = {\n    string.toCharArray.map(c => {\n      val p = math.random\n      if (p > .3) c.toLower\n      else if (p > .05) c.toUpper\n      else '-'\n    }).mkString\n  }\n  sentences.map(dyingHAL).mkString(\" \")",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\"]"
      }
    }
  }, {
    "id" : 70,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "foreach",
      "extraFields" : { }
    }
  }, {
    "id" : 71,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## foreach",
      "extraFields" : { }
    }
  }, {
    "id" : 72,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "tokens1\n\nvar counts = 0\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\ncounts",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\"]"
      }
    }
  }, {
    "id" : 73,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "filter",
      "extraFields" : { }
    }
  }, {
    "id" : 74,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## filter",
      "extraFields" : { }
    }
  }, {
    "id" : 75,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "tokens1\ntokens1.filter(t => !t.startsWith(\"a\")).size\ntokens1.count(t => !t.startsWith(\"a\"))",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"tokens1\\n\\nvar counts = 0\\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\\ncounts\"]"
      }
    }
  }, {
    "id" : 76,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "fold",
      "extraFields" : { }
    }
  }, {
    "id" : 77,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## fold",
      "extraFields" : { }
    }
  }, {
    "id" : 78,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "tokens1\ntokens1.foldLeft(0)((count, word) => count + word.length)",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"tokens1\\n\\nvar counts = 0\\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\\ncounts\",\"tokens1\\ntokens1.filter(t => !t.startsWith(\\\"a\\\")).size\\ntokens1.count(t => !t.startsWith(\\\"a\\\"))\"]"
      }
    }
  }, {
    "id" : 79,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "flatten",
      "extraFields" : { }
    }
  }, {
    "id" : 80,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## flatten",
      "extraFields" : { }
    }
  }, {
    "id" : 81,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "List(tokens1, tokens2)\nList(tokens1, tokens2).flatten",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"tokens1\\n\\nvar counts = 0\\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\\ncounts\",\"tokens1\\ntokens1.filter(t => !t.startsWith(\\\"a\\\")).size\\ntokens1.count(t => !t.startsWith(\\\"a\\\"))\",\"tokens1\\ntokens1.foldLeft(0)((count, word) => count + word.length)\"]"
      }
    }
  }, {
    "id" : 82,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "flatmap",
      "extraFields" : { }
    }
  }, {
    "id" : 83,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## flatMap",
      "extraFields" : { }
    }
  }, {
    "id" : 84,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "List(tokens1, tokens2).map(_ :+ \"STOP\")\nList(tokens1, tokens2).flatMap(_ :+ \"STOP\")",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"tokens1\\n\\nvar counts = 0\\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\\ncounts\",\"tokens1\\ntokens1.filter(t => !t.startsWith(\\\"a\\\")).size\\ntokens1.count(t => !t.startsWith(\\\"a\\\"))\",\"tokens1\\ntokens1.foldLeft(0)((count, word) => count + word.length)\",\"List(tokens1, tokens2)\\nList(tokens1, tokens2).flatten\"]"
      }
    }
  }, {
    "id" : 85,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "performance",
      "extraFields" : { }
    }
  }, {
    "id" : 86,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## [Performance Characteristics](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)",
      "extraFields" : { }
    }
  }, {
    "id" : 87,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "compose",
      "extraFields" : { }
    }
  }, {
    "id" : 88,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## compose",
      "extraFields" : { }
    }
  }, {
    "id" : 89,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def sigmoid(: Double) = 1 / (1 + math.exp(-))\nsigmoid(3)\n\ndef plusOne(i: Double) = i + 1\nval fun1 = sigmoid _ compose plusOne\nfun1(2) //sigmoid(plusOne(2))",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"tokens1\\n\\nvar counts = 0\\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\\ncounts\",\"tokens1\\ntokens1.filter(t => !t.startsWith(\\\"a\\\")).size\\ntokens1.count(t => !t.startsWith(\\\"a\\\"))\",\"tokens1\\ntokens1.foldLeft(0)((count, word) => count + word.length)\",\"List(tokens1, tokens2)\\nList(tokens1, tokens2).flatten\",\"List(tokens1, tokens2).map(_ :+ \\\"STOP\\\")\\nList(tokens1, tokens2).flatMap(_ :+ \\\"STOP\\\")\"]"
      }
    }
  }, {
    "id" : 90,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "andThen",
      "extraFields" : { }
    }
  }, {
    "id" : 91,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## andThen",
      "extraFields" : { }
    }
  }, {
    "id" : 92,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val fun2 = sigmoid _ andThen plusOne\nfun2(3) //plusOne(sigmoid(3))\n(sigmoid _ andThen plusOne)(9) == (plusOne _ compose sigmoid)(9)",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"tokens1\\n\\nvar counts = 0\\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\\ncounts\",\"tokens1\\ntokens1.filter(t => !t.startsWith(\\\"a\\\")).size\\ntokens1.count(t => !t.startsWith(\\\"a\\\"))\",\"tokens1\\ntokens1.foldLeft(0)((count, word) => count + word.length)\",\"List(tokens1, tokens2)\\nList(tokens1, tokens2).flatten\",\"List(tokens1, tokens2).map(_ :+ \\\"STOP\\\")\\nList(tokens1, tokens2).flatMap(_ :+ \\\"STOP\\\")\",\"def sigmoid(: Double) = 1 / (1 + math.exp(-))\\nsigmoid(3)\\n\\ndef plusOne(i: Double) = i + 1\\nval fun1 = sigmoid _ compose plusOne\\nfun1(2) //sigmoid(plusOne(2))\"]"
      }
    }
  }, {
    "id" : 93,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "pipeline",
      "extraFields" : { }
    }
  }, {
    "id" : 94,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## NLP Pipeline with andThen",
      "extraFields" : { }
    }
  }, {
    "id" : 95,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "object SentenceSplitter extends (String => Seq[String]) {\n  override def apply(v1: String): Seq[String] =\n    v1.split(\"[.!?]\").toList\n}\nobject TokenSplitter extends (Seq[String] => Seq[Seq[String]]) {\n  override def apply(v1: Seq[String]): Seq[Seq[String]] =\n    v1.map(s => s.split(\" \").toList)\n}\nval pipeline = SentenceSplitter andThen TokenSplitter\npipeline(\"Of course, the whole point of a Doomsday Machine \" +\n         \"is lost, if you *keep* it a *secret*! Why didn't \" +\n         \"you tell the world, EH?\")",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"tokens1\\n\\nvar counts = 0\\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\\ncounts\",\"tokens1\\ntokens1.filter(t => !t.startsWith(\\\"a\\\")).size\\ntokens1.count(t => !t.startsWith(\\\"a\\\"))\",\"tokens1\\ntokens1.foldLeft(0)((count, word) => count + word.length)\",\"List(tokens1, tokens2)\\nList(tokens1, tokens2).flatten\",\"List(tokens1, tokens2).map(_ :+ \\\"STOP\\\")\\nList(tokens1, tokens2).flatMap(_ :+ \\\"STOP\\\")\",\"def sigmoid(: Double) = 1 / (1 + math.exp(-))\\nsigmoid(3)\\n\\ndef plusOne(i: Double) = i + 1\\nval fun1 = sigmoid _ compose plusOne\\nfun1(2) //sigmoid(plusOne(2))\",\"val fun2 = sigmoid _ andThen plusOne\\nfun2(3) //plusOne(sigmoid(3))\\n(sigmoid _ andThen plusOne)(9) == (plusOne _ compose sigmoid)(9)\"]"
      }
    }
  }, {
    "id" : 96,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "forcomprehension",
      "extraFields" : { }
    }
  }, {
    "id" : 97,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "## for comprehension",
      "extraFields" : { }
    }
  }, {
    "id" : 98,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "case class Sentence(tokens: Seq[String])\ncase class Document(sentences: Seq[Sentence])\n\nval docs = Seq(\n    Document(Seq(Sentence(Seq(\"I\", \"like\", \"Scala\", \".\")))),\n    Document(Seq(Sentence(Seq(\"Really\", \"?\")),\n                 Sentence(Seq(\"I\", \"like\", \"NLP\", \".\")))))\n\nvar shortTokens = 0\nfor (doc <- docs)\n  for (sentence <- doc.sentences)\n    for (token <- sentence.tokens)\n      if (token.length < 3) shortTokens += 1\nshortTokens",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"tokens1\\n\\nvar counts = 0\\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\\ncounts\",\"tokens1\\ntokens1.filter(t => !t.startsWith(\\\"a\\\")).size\\ntokens1.count(t => !t.startsWith(\\\"a\\\"))\",\"tokens1\\ntokens1.foldLeft(0)((count, word) => count + word.length)\",\"List(tokens1, tokens2)\\nList(tokens1, tokens2).flatten\",\"List(tokens1, tokens2).map(_ :+ \\\"STOP\\\")\\nList(tokens1, tokens2).flatMap(_ :+ \\\"STOP\\\")\",\"def sigmoid(: Double) = 1 / (1 + math.exp(-))\\nsigmoid(3)\\n\\ndef plusOne(i: Double) = i + 1\\nval fun1 = sigmoid _ compose plusOne\\nfun1(2) //sigmoid(plusOne(2))\",\"val fun2 = sigmoid _ andThen plusOne\\nfun2(3) //plusOne(sigmoid(3))\\n(sigmoid _ andThen plusOne)(9) == (plusOne _ compose sigmoid)(9)\",\"object SentenceSplitter extends (String => Seq[String]) {\\n  override def apply(v1: String): Seq[String] =\\n    v1.split(\\\"[.!?]\\\").toList\\n}\\nobject TokenSplitter extends (Seq[String] => Seq[Seq[String]]) {\\n  override def apply(v1: Seq[String]): Seq[Seq[String]] =\\n    v1.map(s => s.split(\\\" \\\").toList)\\n}\\nval pipeline = SentenceSplitter andThen TokenSplitter\\npipeline(\\\"Of course, the whole point of a Doomsday Machine \\\" +\\n         \\\"is lost, if you *keep* it a *secret*! Why didn't \\\" +\\n         \\\"you tell the world, EH?\\\")\"]"
      }
    }
  }, {
    "id" : 99,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "shortTokens = 0\nfor (doc <- docs)\n  for (sentence <- doc.sentences)\n    for (token <- sentence.tokens)\n      if (token.length < 3) shortTokens += 1\nshortTokens\n",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"tokens1\\n\\nvar counts = 0\\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\\ncounts\",\"tokens1\\ntokens1.filter(t => !t.startsWith(\\\"a\\\")).size\\ntokens1.count(t => !t.startsWith(\\\"a\\\"))\",\"tokens1\\ntokens1.foldLeft(0)((count, word) => count + word.length)\",\"List(tokens1, tokens2)\\nList(tokens1, tokens2).flatten\",\"List(tokens1, tokens2).map(_ :+ \\\"STOP\\\")\\nList(tokens1, tokens2).flatMap(_ :+ \\\"STOP\\\")\",\"def sigmoid(: Double) = 1 / (1 + math.exp(-))\\nsigmoid(3)\\n\\ndef plusOne(i: Double) = i + 1\\nval fun1 = sigmoid _ compose plusOne\\nfun1(2) //sigmoid(plusOne(2))\",\"val fun2 = sigmoid _ andThen plusOne\\nfun2(3) //plusOne(sigmoid(3))\\n(sigmoid _ andThen plusOne)(9) == (plusOne _ compose sigmoid)(9)\",\"object SentenceSplitter extends (String => Seq[String]) {\\n  override def apply(v1: String): Seq[String] =\\n    v1.split(\\\"[.!?]\\\").toList\\n}\\nobject TokenSplitter extends (Seq[String] => Seq[Seq[String]]) {\\n  override def apply(v1: Seq[String]): Seq[Seq[String]] =\\n    v1.map(s => s.split(\\\" \\\").toList)\\n}\\nval pipeline = SentenceSplitter andThen TokenSplitter\\npipeline(\\\"Of course, the whole point of a Doomsday Machine \\\" +\\n         \\\"is lost, if you *keep* it a *secret*! Why didn't \\\" +\\n         \\\"you tell the world, EH?\\\")\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\"]"
      }
    }
  }, {
    "id" : 100,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "shortTokens = 0\nfor {\n  doc <- docs\n  sentence <- doc.sentences\n  token <- sentence.tokens\n  if token.length < 3\n} shortTokens += 1\nshortTokens",
      "extraFields" : {
        "aggregatedCells" : "[\"1.5 + 1.21828189\",\"\\\"Soft\\\" + \\\" \\\" + \\\"kitty,\\\" + \\\" warm\\\".+(\\\" kitty\\\")\",\"if (2 > 5 || 5 > 2) 7 else 4 \",\"val value = \\\"I cannot be changed! Really!\\\"\\n// value = \\\"But surely, this is not true?!\\\"\\nvalue\",\"var variable = \\\"However, I can!\\\"\\nvariable = \\\"See? I can change!\\\"\\nvariable\",\"def depluralizer(word: String) =\\n   if (word.takeRight(4) == \\\"sses\\\" || word.takeRight(3) == \\\"ies\\\" )\\n     word.stripSuffix(\\\"es\\\")\\n   else if (word.takeRight(2) == \\\"ss\\\")\\n     word\\n   else\\n     word.stripSuffix(\\\"s\\\")\\ndef exclamator(word: String) = word + \\\"!\\\"\\nval removeIng = (word: String) => word.stripSuffix(\\\"ing\\\")\\ndepluralizer(\\\"businesses\\\")\",\"// partial function application\\ndef addSuffix(stem: String, suffix: String): String =\\n  stem + suffix\\nval addIng = addSuffix(_:String, \\\"ing\\\")\\naddIng(\\\"Learn\\\")\\n// currying\\ndef addWords(w1: String)(w2: String)(w3: String): String =\\n  w1 + \\\" \\\" + w2 + \\\" \\\" + w3\\nval curried = addWords _\\nval soft = curried(\\\"soft\\\")\\nval kitty = soft(\\\"kitty\\\")\\nkitty(\\\"warm\\\")\",\"def concatenateAll(joiningSym: String, args: String*) = {\\n args.foldLeft(\\\"\\\")((x: String, y: String) => x + joiningSym + y)\\n}\\nconcatenateAll(\\\"+\\\",\\\"soft\\\", \\\"kitty\\\", \\\"warm\\\", \\\"kitty\\\")\",\"def step1stemmer(word: String): String = {\\n word match {\\n   case i if (i.takeRight(1)==\\\"s\\\") => depluralizer(i)\\n   case i if (i.takeRight(3)==\\\"ing\\\") => removeIng(i)\\n   case i if (i.takeRight(2)==\\\"ed\\\") => word.stripSuffix(\\\"ed\\\")\\n }\\n}\\nstep1stemmer(\\\"learning\\\")\",\"def factorial(n: Int): Int = {\\n n match {\\n  case 0 | 1 => 1\\n  case x => x * factorial(n-1)\\n }\\n}\\nfactorial(5)\",\"def parseArgument(arg: String, value: Any): String =\\n  (arg, value) match {\\n case (\\\"-x\\\", x) => \\\"-x\\\" + x\\n case (\\\"-v\\\", v: Int) if (v<3) => \\\"-v < 3\\\"\\n case (\\\"-v\\\", weird_value) => \\\"-v weird value!!\\\"\\n case unk => \\\"An unknown argument: \\\" + unk\\n}\\nparseArgument(\\\"-v\\\", 0.5)\",\"abstract class Node\\ncase class Split(left: Node, right: Node) extends Node\\ncase class Leaf(value: Int) extends Node\\nval tree = Split(Leaf(2),Split(Leaf(1),Leaf(10)))\\n\\ndef sum(tree: Node): Int = tree match {\\n case Leaf(n) => n\\n case Split(left, right) => sum(left) + sum(right)\\n}\\n\\nsum(tree)\",\"var ok: Boolean = true\\nval computation: Double = try {\\n 1 / 0\\n} catch {\\ncase e: ArithmeticException => {ok = false; Double.NaN}\\n} finally {\\nok = false\\n}\\n\\n\\\"computation=%f, ok=%s\\\".format(computation,ok)\",\"def ??? : Nothing = throw new NotImplementedError\\n\\n//todo, but already compiles\\ndef answerToLifeTheUniverseAndEverything() = ???\\ndef question(s: String) = s match {\\n  case \\\"the answer to life the universe and everything\\\" =>\\n    answerToLifeTheUniverseAndEverything()\\n  case _ => ???\\n}\\n\\n//already done\\ndef answerOnePlusOne() = 2\\nanswerOnePlusOne()\",\"val tokens1 = List(\\\"All\\\", \\\"work\\\", \\\"and\\\", \\\"no\\\", \\\"play\\\", \\\"makes\\\",\\n                   \\\"Jack\\\", \\\"a\\\", \\\"dull\\\", \\\"boy\\\", \\\".\\\")\\ntokens1\\ntokens1.head\\ntokens1.tail\\n\\\"Jack Torrance: \\\" :: tokens1\",\"val tokens2 = List(\\\"Jack\\\", \\\"!\\\", \\\"What\\\", \\\"...\\\", \\\"are\\\", \\\"you\\\", \\\"?\\\")\\ntokens2\\nval tokens3 = tokens1 ++ tokens2\\ntokens3\\ntokens3.distinct\",\"val words1 = Set(\\\"Do\\\", \\\",\\\", \\\"or\\\", \\\"do\\\", \\\"not\\\", \\\".\\\",\\n                 \\\"There\\\", \\\"is\\\", \\\"no\\\", \\\"try\\\", \\\".\\\")\\nwords1\\n\\nval words2 = Set(\\\"A\\\", \\\"martini\\\", \\\".\\\",\\n                 \\\"Shaken\\\", \\\",\\\", \\\"not\\\", \\\"stirred\\\", \\\".\\\")\\nwords1 union words2\\n\\nwords1 intersect words2\\n\\nwords1 diff words2\",\"val lemmas = Map(\\\"saving\\\" -> \\\"save\\\", \\\"tokens\\\" -> \\\"token\\\",\\n                 \\\"token\\\" -> \\\"token\\\", \\\"occurring\\\" -> \\\"occur\\\")\\nlemmas\\nlemmas(\\\"tokens\\\")\\nlemmas.keySet\",\"val wordCount = (\\\"like\\\", 2)\\nwordCount._2\\nwordCount._1\\n\\\"like\\\" -> 2 == (\\\"like\\\", 2)\",\"val lemmaOpt1 = lemmas.get(\\\"tokens\\\")\\nlemmaOpt1\\nlemmaOpt1.get\\n\\nval lemmaOpt2 = lemmas.get(\\\"Open the pod bay doors, HAL.\\\")\\nlemmaOpt2\\n\\nif (lemmaOpt2.isDefined)\\n  lemmaOpt2.get\\nelse\\n  \\\"I'm sorry, Dave.\\\"\\n  \\nlemmaOpt2.getOrElse(\\\"I'm afraid I can't do that.\\\").toString\",\"val sentences = List(\\\"Daisy, Daisy, give me your answer do.\\\",\\n                     \\\"I'm half crazy all for the love of you.\\\")\\n//sentences.head.toCharArray.map(c => c.toLower).mkString\",\"  def dyingHAL(string: String) = {\\n    string.toCharArray.map(c => {\\n      val p = math.random\\n      if (p > .3) c.toLower\\n      else if (p > .05) c.toUpper\\n      else '-'\\n    }).mkString\\n  }\\n  sentences.map(dyingHAL).mkString(\\\" \\\")\",\"tokens1\\n\\nvar counts = 0\\ntokens1.foreach(t => t.toCharArray.foreach(c => counts += 1))\\ncounts\",\"tokens1\\ntokens1.filter(t => !t.startsWith(\\\"a\\\")).size\\ntokens1.count(t => !t.startsWith(\\\"a\\\"))\",\"tokens1\\ntokens1.foldLeft(0)((count, word) => count + word.length)\",\"List(tokens1, tokens2)\\nList(tokens1, tokens2).flatten\",\"List(tokens1, tokens2).map(_ :+ \\\"STOP\\\")\\nList(tokens1, tokens2).flatMap(_ :+ \\\"STOP\\\")\",\"def sigmoid(: Double) = 1 / (1 + math.exp(-))\\nsigmoid(3)\\n\\ndef plusOne(i: Double) = i + 1\\nval fun1 = sigmoid _ compose plusOne\\nfun1(2) //sigmoid(plusOne(2))\",\"val fun2 = sigmoid _ andThen plusOne\\nfun2(3) //plusOne(sigmoid(3))\\n(sigmoid _ andThen plusOne)(9) == (plusOne _ compose sigmoid)(9)\",\"object SentenceSplitter extends (String => Seq[String]) {\\n  override def apply(v1: String): Seq[String] =\\n    v1.split(\\\"[.!?]\\\").toList\\n}\\nobject TokenSplitter extends (Seq[String] => Seq[Seq[String]]) {\\n  override def apply(v1: Seq[String]): Seq[Seq[String]] =\\n    v1.map(s => s.split(\\\" \\\").toList)\\n}\\nval pipeline = SentenceSplitter andThen TokenSplitter\\npipeline(\\\"Of course, the whole point of a Doomsday Machine \\\" +\\n         \\\"is lost, if you *keep* it a *secret*! Why didn't \\\" +\\n         \\\"you tell the world, EH?\\\")\",\"case class Sentence(tokens: Seq[String])\\ncase class Document(sentences: Seq[Sentence])\\n\\nval docs = Seq(\\n    Document(Seq(Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"Scala\\\", \\\".\\\")))),\\n    Document(Seq(Sentence(Seq(\\\"Really\\\", \\\"?\\\")),\\n                 Sentence(Seq(\\\"I\\\", \\\"like\\\", \\\"NLP\\\", \\\".\\\")))))\\n\\nvar shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\",\"shortTokens = 0\\nfor (doc <- docs)\\n  for (sentence <- doc.sentences)\\n    for (token <- sentence.tokens)\\n      if (token.length < 3) shortTokens += 1\\nshortTokens\\n\"]"
      }
    }
  } ],
  "config" : { }
}
