{
  "name" : "Parsing",
  "cells" : [ {
    "id" : 0,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nNote that this chapter is heavily influenced by the structure and content of [Mike Collins' PCFG lecture](http://www.cs.columbia.edu/~mcollins/courses/nlp2011/notes/pcfgs.pdf). <span class=\"summary\">Based on Mike Collins [Lecture](http://www.cs.columbia.edu/~mcollins/courses/nlp2011/notes/pcfgs.pdf).</span> \n\n<div class=\"newslide\"></div>\nIn many NLP applications it is useful to understand the syntactic structure of a sentence: where are the verbs, what are the subject and object of the verbs, which phrases form coherent sub-structures of the sentence? Understanding this enables the machine to more effectively translate from Japanese to English, or to understand the query [\"who is the president of the united state\"](https://www.google.co.uk/search?q=who+is+the+president+of+the+united+state&oq=who+is+the+president+of+the+united+state&aqs=chrome..69i57j0l5.252j0j4&sourceid=chrome&es_sm=119&ie=UTF-8) and execute it against a database. <span class=\"summary\">It is useful to understand the syntactic structure of a sentence: where are the _verbs_, what are the _subject_ and _object_ of the verbs, which _phrases_ form coherent _sub-structures_?</span>  \n\n<div class=\"newslide\"></div>\nIn linguistics these questions are asked in the field of **syntax**, from the Greek syntaxis (arrangement). There are three core concepts:\n\n* **Constituency**: groups of words act as single units.\n* **Grammatical Relations**: object, subject, direct object etc. \n* **Subcategorization**: restrictions on the type of phrases that go with certain words.\n\n<div class=\"newslide\"></div>\n### Context Free Grammars\nA common approach to capture constituency, grammatical relations and subcategorization is based on [Context Free Grammars](https://www.cs.rochester.edu/~nelson/courses/csc_173/grammars/cfg.html) (CFGs). On a high level, these grammars assume that legal sentences can be derived by repeatedly and _independently_ expanding abstract symbols (such as \"NounPhrase\" or \"Adjective\") into more concrete sequences of symbols (such as \"Adjective Noun\" or \"green\") until each symbol is a concrete word. <span class=\"summary\">Context Free Grammars define rules that expand ...</span> \n\n<div class=\"newslide\"></div>\nMore formally, a CFG is a 4-tuple \\\\(G=(N,\\Sigma,R,S)\\\\) where\n\n  * \\\\(N\\\\) is a set of _non-terminal symbols_.\n  * \\\\(\\Sigma\\\\) is a set of _terminal symbols_.\n  * \\\\(R\\\\) is a finite set of _rules_ \\\\(X \\rightarrow Y_1 Y_2\\ldots Y_n\\\\) where \\\\(X \\in N\\\\) and \\\\(Y_i \\in N \\cup \\Sigma\\\\). \n  * \\\\(S \\in N\\\\) is a _start symbol_. \n\n<div class=\"newslide\"></div>\nBefore we show examples, let us define a scala data structure for PCFGs.",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "sealed trait RHS\ncase class NonTerminal(name:Symbol) extends RHS \ncase class Terminal(name:String) extends RHS \ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\n1",
      "extraFields" : {
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 2,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nLet us now create an example CFG. Notice that we implemented a  implicit conversion methods which will allow us to construct terminals, non-terminals and rules more succinctly. We omit these methods here for brevity. <span class=\"summary\">Let us now create an example CFG</span> ",
      "extraFields" : { }
    }
  }, {
    "id" : 3,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "implicit def toNonTerm(name:Symbol) = NonTerminal(name)\nimplicit def toTerm(word:String) = Terminal(word)\nval anyToRhs:PartialFunction[Any,RHS] = {\n  case s:String => toTerm(s) \n  case s:Symbol => toNonTerm(s) \n}\nimplicit def toRule1(rule:(Symbol,List[Any])) = \n  Rule(rule._1,rule._2.collect(anyToRhs)) \n\nimplicit def toRule2(rule:(Symbol,Any)) = \n  Rule(rule._1,List(anyToRhs(rule._2))) \n    \ndef rhsToString(rhs:RHS) = rhs match {\n  case NonTerminal(n) => n.toString\n  case Terminal(w) => w\n}    \nimplicit def toHTML(cfg:CFG) = {\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\n    }  \n  }      \n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\" \"))))    \n}\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\" \"))))    \n}\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\n  CFG(nonTerminals,terminals,rules.toList,start)\n}  ",
      "extraFields" : {
        "hide" : "true",
        "hide_output" : "true",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\"]"
      }
    }
  }, {
    "id" : 4,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val cfg = cfgFromRules('S,\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \n  'NP_p -> List(\"Matko\",\"raps\"),\n  'VP_p -> List(\"are\", 'ADJ),\n  'NP_s -> List(\"Matko\"),\n  'VP_s -> List(\"raps\", \"in\", \"StatNLP\"),\n  'ADJ -> \"silly\")\ncfg ",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \"]"
      }
    }
  }, {
    "id" : 5,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### (Left-most) Derivation\nA left-most derivation given a CFG \\\\(G\\\\) is a sequence of strings \\\\(s_1 \\ldots s_n\\\\) such that \n\n* \\\\(s_1 = S\\\\), that is, the first string consists only of the start symbol.\n* \\\\(s_n \\in \\Sigma^*\\\\), that is, the last string consists of only terminals.\n* Each \\\\(s_i\\\\) for \\\\(i > 1\\\\) is generated by replacing the left-most non-terminal \\\\(\\alpha\\\\) with the right-hand side of any rule that has \\\\(\\alpha\\\\) as left-hand side. \n\n<div class=\"newslide\"></div>\nLet us write some code that puts this definition into action and generates random derivations based on a grammar. ",
      "extraFields" : { }
    }
  }, {
    "id" : 6,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import scala.collection.mutable.{ArrayBuffer,ListBuffer}\nval rand = new scala.util.Random(0) \n@scala.annotation.tailrec\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\n    case Some((n,index)) =>\n      val rules =  cfg.R.filter(_.lhs == n)\n      val sampled = rules(rand.nextInt(rules.length))\n      val next = sentence.patch(index,sampled.rhs,1) \n      generateDeriv(cfg, next, result.get :+ next)\n    case None => result \n  }",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \"]",
        "hide_output" : "true"
      }
    }
  }, {
    "id" : 7,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nLet us generate an example derivation.",
      "extraFields" : { }
    }
  }, {
    "id" : 8,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "generateDeriv(cfg,Seq(cfg.S)) ",
      "extraFields" : {
        "cache" : "false",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\"]"
      }
    }
  }, {
    "id" : 9,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Parse Trees\nDerivations can be compactly present as trees where each non-leaf node corresponds to an expanded left-hand-side and its children to the rules' right hand side.\n<span class=\"summary\">Derivations can be compactly present as trees where each non-leaf node corresponds to an expanded left-hand-side and its children to the rules' right hand side.</summary>\n\n<div class=\"newslide\"></div>\n<span class=\"summary\">A scala data structure to represent trees</summary>",
      "extraFields" : { }
    }
  }, {
    "id" : 10,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "sealed trait ParseTree { def node: RHS}\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\ncase class Leaf(node:Terminal) extends ParseTree",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \"]",
        "hide_output" : "true"
      }
    }
  }, {
    "id" : 11,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import ml.wolfe.nlp.syntax._\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\n  case Leaf(Terminal(w)) => RenderTree(w,\"terminal\")\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \"nonterminal\",children map toRenderTree)\n}\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\n",
      "extraFields" : {
        "hide" : "true",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\"]",
        "hide_output" : "true"
      }
    }
  }, {
    "id" : 12,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "We can construct trees through parse the usual case class constructors, and render them graphically.",
      "extraFields" : { }
    }
  }, {
    "id" : 13,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "Node('S, List(Node('NP_p, List(Leaf(\"Matko\"), Leaf(\"raps\"))),\n              Node('VP_p,List(Leaf(\"are\"), Leaf(\"silly\")))))",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\"]"
      }
    }
  }, {
    "id" : 14,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nIn the same way we could generate derivations before, we can now generate parse trees from a CFG.",
      "extraFields" : { }
    }
  }, {
    "id" : 15,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\n  case t:Terminal => Leaf(t)\n  case n:NonTerminal =>\n    val rules =  cfg.R.filter(_.lhs == n)\n    val sampled = rules(rand.nextInt(rules.length))\n    val children = sampled.rhs.map(generateTree(cfg,_))\n    Node(n,children)\n} ",
      "extraFields" : {
        "hide_output" : "true",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\"]"
      }
    }
  }, {
    "id" : 16,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nNow let us generate a tree, starting from a non-terminal in the CFG.",
      "extraFields" : { }
    }
  }, {
    "id" : 17,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "generateTree(cfg,'S)     ",
      "extraFields" : {
        "cache" : "false",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \"]"
      }
    }
  }, {
    "id" : 18,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Finding Parse Trees\nAs you can see, parse trees uncover how a sentence is structured with respect to a grammar. In fact, they give us insights about both constituency and grammatical relations: In the above case the subtrees headed by \"NP\" nodes represent noun phrase constituents; likewise, the \"NP\" and \"VP\" subtrees under \"S\" represent the subject and object of a sentence. It is interesting to generate trees and hence sentences given a starting symbol. However, in practice it is often more useful to find a parse tree given a sentence, if existent. This process is generally referred to as parsing. <span class=\"summary\"> **Parsing**: find a legal parse tree given a sentence and a grammar.</span>\n\nThere are a couple of approaches to find a legal parse tree given a sentence and grammar:<span class=\"summary\"></span>\n\n* **Top-Down**: Start with the start symbol and generate trees; backtrack if they do not match observed sentence.\n* **Bottom-Up**: Start with the sentence, and find rules that generate parts of it; backtrack if no start symbol can be induced.\n* **Dynamic Programming**: Explore several trees in parallel and re-use computations.\n\n<div class=\"newslide\"></div>\n#### Bottom-Up Parsing with Backtracking\nA bottom-up parser with backtracking maintains a state consisting of a stack of processed trees, and buffer of remaining words, and a history of previous states we can backtrack to if we cannot make more progress. Roughly speaking, the algorithm proceeds by iteratively reducing the stack via rules to new trees, moving forward in the sentence, and backtracking to previous states when we reach the end of the sentence but cannot create a single tree. <span class=\"summary\"> **Reduce** a stack of trees using rules, **shift** tokens on the stack, **backtrack** when we reach the end but have more than one tree on the stack.</span>\n\n<div class=\"newslide\"></div>\nIn Scala code the parsing algorithm can be formulated as follows. Notice the use of immutable data structures which makes storing and recalling previous states very efficient. Also notice that we record a history of transitions. This is not needed for the algorithm to work, but allows us to inspect its behaviour afterwards. <span class=\"summary\">A scala bottom up parser:</span>",
      "extraFields" : { }
    }
  }, {
    "id" : 19,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "type Stack = List[ParseTree]\ntype Buffer = List[String]\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\ncase class Transition(state:State, op:Symbol)\n\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\n  var history:List[State] = Nil\n  var state = State(Nil,sentence,Nil)\n  var transitions = Transition(state,'Init) :: Nil\n  def reduce() {\n    while (state.rules.nonEmpty) {\n      val rule = state.rules.head\n      val top = state.stack.take(rule.rhs.length).reverse\n      if (top.map(_.node) == rule.rhs) {\n        history = state :: history \n        state = state.copy(\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\n          rules = cfg.R\n        )\n        transitions = Transition(state,'Reduce) :: transitions\n\n      } else state = state.copy(rules = state.rules.tail)\n    }   \n  }\n  def shift() {\n    state = state.copy(\n      stack = Leaf(state.buffer.head) :: state.stack,  \n      buffer = state.buffer.tail, \n      rules = cfg.R\n    )\n    transitions = Transition(state,'Shift) :: transitions\n  }\n  def backtrack() {\n    state = history.head.copy(rules = history.head.rules.tail) \n    transitions = Transition(state,'Backtrack) :: transitions\n    history = history.tail\n  }\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\n    if (state.rules.nonEmpty) reduce()\n    if (state.buffer.nonEmpty) shift() \n    else if (state.stack.length > 1) backtrack()\n  }\n  transitions \n} ",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \"]"
      }
    }
  }, {
    "id" : 20,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def treeToString(tree:ParseTree):String = tree match {\n  case Node(NonTerminal(n), children) => s\"($n ${children.map(treeToString).mkString(\" \")})\"\n  case Leaf(Terminal(w)) => w\n}\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\" | \"),t.state.buffer.mkString(\" \"))\n  table(transitions.map(toRow))\n}\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\n   case _ => List(tree)\n} \ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head",
      "extraFields" : {
        "hide" : "true",
        "hide_output" : "true",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \"]"
      }
    }
  }, {
    "id" : 21,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "Let us run an example parse.",
      "extraFields" : { }
    }
  }, {
    "id" : 22,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "bottomUpParse(cfg, List(\"MCRiedel\", \"raps\", \"are\", \"silly\")).reverse     ",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\\n   case _ => List(tree)\\n} \\ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head\"]"
      }
    }
  }, {
    "id" : 23,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Dynamic Programming for Parsing\nA problem with the bottom-up parser is the fact that, after back-tracking, it may redo many steps it had already before (can you find examples of this behaviour in the transitions above?). This suggests to remember steps and re-use then when needed. This is the general idea behind _dynamic programm_: caching and reusing computation whenever possible. \n\n<div class=\"newslide\"></div>\n#### Chomsky Normal Form\nIn the case of CFG parsing there exists a very effective dynamic program, the so-called CockeYoungerKasami (CYK) algorithm. However, before we can apply this algorithm we need to _normalize_ the grammar. In particular, we need to make sure that each rule has one of the following forms:\n\n* \\\\(\\alpha \\rightarrow \\beta \\gamma\\\\) where \\\\(\\beta,\\gamma \\in N \\setminus \\\\{ S  \\\\} \\\\). \n* \\\\(\\alpha \\rightarrow t\\\\) where \\\\(t \\in \\Sigma\\\\).\n\n \nIn words: each rule is either binary and expands into two non-terminal non-Start symbols, or unary and expands into a word. This form is called _Chomsky Normal Form_ (CNF). \n\n<div class=\"newslide\"></div>\nFortunately we can convert every CFG into an equivalent CFG in CNF, in the sense that any derivation or parse of sentence in one grammar can be loss-lessly converted to a derivation in the other grammar. We present this conversion in scala below, but omitted cases not relevant to our grammar (Exercise: add these cases).\n\n",
      "extraFields" : { }
    }
  }, {
    "id" : 24,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "@scala.annotation.tailrec\ndef toCNF(cfg:CFG, result:CFG = CFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):CFG = {\n  cfg.R match {\n    case Rule(lhs,rhs) :: tail if (rhs.length > 2) =>\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\n      val rule1 = Rule(lhs, leftN :: rhs.drop(2))\n      val rule2 = Rule(leftN, rhs.take(2))\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\n    case Rule(lhs, (l1:Terminal) :: l2 :: Nil) :: tail => \n      val n = NonTerminal(Symbol(l1.name + id))\n      val rule1 = Rule(lhs, n :: l2 :: Nil)\n      val rule2 = Rule(n,l1 :: Nil)\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\n    case Rule(lhs,l1 :: (l2:Terminal) :: Nil) :: tail => \n      val n = NonTerminal(Symbol(l2.name + id))\n      val rule1 = Rule(lhs, l1 :: n :: Nil)\n      val rule2 = Rule(n, l2 :: Nil)\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\n    case h :: tail => toCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\n    case Nil => result  \n  }    \n} \nval cnf = toCNF(cfg) ",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\\n   case _ => List(tree)\\n} \\ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head\",\"bottomUpParse(cfg, List(\\\"MCRiedel\\\", \\\"raps\\\", \\\"are\\\", \\\"silly\\\")).reverse     \"]"
      }
    }
  }, {
    "id" : 25,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n#### CYK algorithm\nThe CYK algorithm caches, for each span in the sentence, all possible trees that can cover the span according to the CFG. Again we record all changes throughout the algorithm for later visualization. ",
      "extraFields" : { }
    }
  }, {
    "id" : 26,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "type Chart = Map[(Int,Int),List[ParseTree]]\ndef cyk(cfg:CFG, s:IndexedSeq[String]) = {\n  var chart:Chart = Map.empty withDefaultValue Nil\n  var charts:List[Chart] = Nil\n  val n = s.length\n  //init\n  for (i <- 0 until n) {\n    chart +=  (i,i) -> cfg.R.collect { \n        case Rule(rhs,(t@Terminal(w)) :: Nil) if w == s(i) => Node(rhs, Leaf(t) :: Nil)}\n    charts ::= chart  \n  }\n  for (l <- 1 until n; b <- 0 until n - l; e = b + l; m <- b until e) {\n    val trees = for (left@Node(nl,_) <- chart(b,m); \n                     right@Node(nr,_) <- chart(m + 1,e);\n                     rule <- cfg.R.filter(_.rhs == nl :: nr :: Nil)) yield {\n      Node(rule.lhs, left :: right :: Nil)      \n    } \n    chart += (b,e) -> (trees ::: chart(b,e))\n    charts ::= chart\n  }\n  charts\n}\n",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\\n   case _ => List(tree)\\n} \\ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head\",\"bottomUpParse(cfg, List(\\\"MCRiedel\\\", \\\"raps\\\", \\\"are\\\", \\\"silly\\\")).reverse     \",\"@scala.annotation.tailrec\\ndef toCNF(cfg:CFG, result:CFG = CFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):CFG = {\\n  cfg.R match {\\n    case Rule(lhs,rhs) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = Rule(lhs, leftN :: rhs.drop(2))\\n      val rule2 = Rule(leftN, rhs.take(2))\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs, (l1:Terminal) :: l2 :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = Rule(lhs, n :: l2 :: Nil)\\n      val rule2 = Rule(n,l1 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs,l1 :: (l2:Terminal) :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = Rule(lhs, l1 :: n :: Nil)\\n      val rule2 = Rule(n, l2 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\nval cnf = toCNF(cfg) \"]",
        "hide_output" : "true"
      }
    }
  }, {
    "id" : 27,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nLet us run the algorithm.",
      "extraFields" : { }
    }
  }, {
    "id" : 28,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "cyk(cnf, Vector(\"Matko\",\"raps\", \"in\", \"StatNLP\")).head(0,3).head ",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\\n   case _ => List(tree)\\n} \\ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head\",\"bottomUpParse(cfg, List(\\\"MCRiedel\\\", \\\"raps\\\", \\\"are\\\", \\\"silly\\\")).reverse     \",\"@scala.annotation.tailrec\\ndef toCNF(cfg:CFG, result:CFG = CFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):CFG = {\\n  cfg.R match {\\n    case Rule(lhs,rhs) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = Rule(lhs, leftN :: rhs.drop(2))\\n      val rule2 = Rule(leftN, rhs.take(2))\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs, (l1:Terminal) :: l2 :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = Rule(lhs, n :: l2 :: Nil)\\n      val rule2 = Rule(n,l1 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs,l1 :: (l2:Terminal) :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = Rule(lhs, l1 :: n :: Nil)\\n      val rule2 = Rule(n, l2 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\nval cnf = toCNF(cfg) \",\"type Chart = Map[(Int,Int),List[ParseTree]]\\ndef cyk(cfg:CFG, s:IndexedSeq[String]) = {\\n  var chart:Chart = Map.empty withDefaultValue Nil\\n  var charts:List[Chart] = Nil\\n  val n = s.length\\n  //init\\n  for (i <- 0 until n) {\\n    chart +=  (i,i) -> cfg.R.collect { \\n        case Rule(rhs,(t@Terminal(w)) :: Nil) if w == s(i) => Node(rhs, Leaf(t) :: Nil)}\\n    charts ::= chart  \\n  }\\n  for (l <- 1 until n; b <- 0 until n - l; e = b + l; m <- b until e) {\\n    val trees = for (left@Node(nl,_) <- chart(b,m); \\n                     right@Node(nr,_) <- chart(m + 1,e);\\n                     rule <- cfg.R.filter(_.rhs == nl :: nr :: Nil)) yield {\\n      Node(rule.lhs, left :: right :: Nil)      \\n    } \\n    chart += (b,e) -> (trees ::: chart(b,e))\\n    charts ::= chart\\n  }\\n  charts\\n}\\n\"]"
      }
    }
  }, {
    "id" : 29,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\n### Ambiguity \nFor real world grammars many phrases have several legal parse trees. Which one is the correct one depends on the intent of the speaker. That said, in many cases it is quite obvious that one parse tree should be more likely, or have a higher _probability_. This suggest a probabilistic treatment of grammars and parsing. Before we introduce probabilistic CFGs, let us inspect a typical case of syntactic natural language ambiguity. <span class=\"summary\">Sentences can have several legal parse trees.</span> \n",
      "extraFields" : { }
    }
  }, {
    "id" : 30,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val ambCFG = cfgFromRules('S,\n  'S -> List('Subj,'VP),\n  'Subj -> \"He\",\n  'Verb -> \"shot\",\n  'VP -> List('Verb,'Obj), 'VP -> List('Verb,'Obj,'PP),\n  'PP -> List(\"in\",\"his\",\"pyjamas\"),\n  'Obj -> List(\"the\",\"elephant\"), 'Obj -> List(\"the\",\"elephant\",'PP)\n) \nfilterNonTerminals(ambCFG.N,cyk(toCNF(ambCFG), Vector(\"He\", \"shot\", \"the\", \"elephant\", \"in\", \"his\", \"pyjamas\")).head(0,6)(0)) ",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\\n   case _ => List(tree)\\n} \\ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head\",\"bottomUpParse(cfg, List(\\\"MCRiedel\\\", \\\"raps\\\", \\\"are\\\", \\\"silly\\\")).reverse     \",\"@scala.annotation.tailrec\\ndef toCNF(cfg:CFG, result:CFG = CFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):CFG = {\\n  cfg.R match {\\n    case Rule(lhs,rhs) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = Rule(lhs, leftN :: rhs.drop(2))\\n      val rule2 = Rule(leftN, rhs.take(2))\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs, (l1:Terminal) :: l2 :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = Rule(lhs, n :: l2 :: Nil)\\n      val rule2 = Rule(n,l1 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs,l1 :: (l2:Terminal) :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = Rule(lhs, l1 :: n :: Nil)\\n      val rule2 = Rule(n, l2 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\nval cnf = toCNF(cfg) \",\"type Chart = Map[(Int,Int),List[ParseTree]]\\ndef cyk(cfg:CFG, s:IndexedSeq[String]) = {\\n  var chart:Chart = Map.empty withDefaultValue Nil\\n  var charts:List[Chart] = Nil\\n  val n = s.length\\n  //init\\n  for (i <- 0 until n) {\\n    chart +=  (i,i) -> cfg.R.collect { \\n        case Rule(rhs,(t@Terminal(w)) :: Nil) if w == s(i) => Node(rhs, Leaf(t) :: Nil)}\\n    charts ::= chart  \\n  }\\n  for (l <- 1 until n; b <- 0 until n - l; e = b + l; m <- b until e) {\\n    val trees = for (left@Node(nl,_) <- chart(b,m); \\n                     right@Node(nr,_) <- chart(m + 1,e);\\n                     rule <- cfg.R.filter(_.rhs == nl :: nr :: Nil)) yield {\\n      Node(rule.lhs, left :: right :: Nil)      \\n    } \\n    chart += (b,e) -> (trees ::: chart(b,e))\\n    charts ::= chart\\n  }\\n  charts\\n}\\n\",\"cyk(cnf, Vector(\\\"Matko\\\",\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\")).head(0,3).head \"]"
      }
    }
  }, {
    "id" : 31,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nThe example is an instance of _prepositional phrase attachment ambiguity_: the \"in his pyjamas\" phrase could both be part of the verb phrase, meaning that the shooting happened in pyjamas, or part of the noun phrase \"the elephant\", meaning that the elephant was in pyjamas. Both readings make syntactic sense, so there is nothing wrong with the grammar. However, we would like the machine to return the preferred reading when such sentence is parsed. For this we need to find a way to assign different readings different probabilities. <span class=\"summary\">Can we assign the better parse a higher _probability_?</span> \n\n<div class=\"newslide\"></div>\n### Probabilistic Context Free Grammars\n[Probabilistic Context Free Grammars](http://www.cs.columbia.edu/~mcollins/courses/nlp2011/notes/pcfgs.pdf) (PFCGs) are Context Free Grammars in which rules have probabilities. More formally, a PCFG consists of \n\n* A Context Free Grammar \\\\(G(N,\\Sigma,R,S)\\\\).\n* A parameter \\\\(q(\\alpha \\rightarrow \\beta)\\\\) for each rule  \\\\(\\alpha \\rightarrow \\beta \\in R\\\\). For each possible left hand side \\\\(\\alpha \\in N\\\\) we require \\\\(\\sum_\\beta q(\\alpha \\rightarrow \\beta) = 1\\\\).\n\nA PCFG defines a probability distribution over parse trees as follows. Given a parse tree \\\\(\\mathbf{t}\\\\) that contains the rules \\\\(\\alpha_1 \\rightarrow \\beta_1, \\ldots, \\alpha_n \\rightarrow \\beta_n\\\\), the probability of this tree under the PCFG is:\n$$\n  \\newcommand{parse}{\\mathbf{t}}\n  p(\\parse) = \\prod_i^n q(\\alpha_i \\rightarrow \\beta_i) \n$$\n\nNotice that we can develop and operate parsers with the structured prediction recipe. We have model \\\\(p\\\\), some parameters \\\\(\\params\\\\) that need to be estimated on a training set, and the prediction/search problem of finding the most likely parse tree given a sentence. The next sections will cover these aspects.\n\n<div class=\"newslide\"></div>\nBefore we show examples, let us define a scala data structure for\nPCFGs.    \n",
      "extraFields" : { }
    }
  }, {
    "id" : 32,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "case class ProbRule(lhs:NonTerminal, rhs: List[RHS],prob:Double)\ncase class PCFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[ProbRule],S:NonTerminal)",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\\n   case _ => List(tree)\\n} \\ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head\",\"bottomUpParse(cfg, List(\\\"MCRiedel\\\", \\\"raps\\\", \\\"are\\\", \\\"silly\\\")).reverse     \",\"@scala.annotation.tailrec\\ndef toCNF(cfg:CFG, result:CFG = CFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):CFG = {\\n  cfg.R match {\\n    case Rule(lhs,rhs) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = Rule(lhs, leftN :: rhs.drop(2))\\n      val rule2 = Rule(leftN, rhs.take(2))\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs, (l1:Terminal) :: l2 :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = Rule(lhs, n :: l2 :: Nil)\\n      val rule2 = Rule(n,l1 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs,l1 :: (l2:Terminal) :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = Rule(lhs, l1 :: n :: Nil)\\n      val rule2 = Rule(n, l2 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\nval cnf = toCNF(cfg) \",\"type Chart = Map[(Int,Int),List[ParseTree]]\\ndef cyk(cfg:CFG, s:IndexedSeq[String]) = {\\n  var chart:Chart = Map.empty withDefaultValue Nil\\n  var charts:List[Chart] = Nil\\n  val n = s.length\\n  //init\\n  for (i <- 0 until n) {\\n    chart +=  (i,i) -> cfg.R.collect { \\n        case Rule(rhs,(t@Terminal(w)) :: Nil) if w == s(i) => Node(rhs, Leaf(t) :: Nil)}\\n    charts ::= chart  \\n  }\\n  for (l <- 1 until n; b <- 0 until n - l; e = b + l; m <- b until e) {\\n    val trees = for (left@Node(nl,_) <- chart(b,m); \\n                     right@Node(nr,_) <- chart(m + 1,e);\\n                     rule <- cfg.R.filter(_.rhs == nl :: nr :: Nil)) yield {\\n      Node(rule.lhs, left :: right :: Nil)      \\n    } \\n    chart += (b,e) -> (trees ::: chart(b,e))\\n    charts ::= chart\\n  }\\n  charts\\n}\\n\",\"cyk(cnf, Vector(\\\"Matko\\\",\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\")).head(0,3).head \",\"val ambCFG = cfgFromRules('S,\\n  'S -> List('Subj,'VP),\\n  'Subj -> \\\"He\\\",\\n  'Verb -> \\\"shot\\\",\\n  'VP -> List('Verb,'Obj), 'VP -> List('Verb,'Obj,'PP),\\n  'PP -> List(\\\"in\\\",\\\"his\\\",\\\"pyjamas\\\"),\\n  'Obj -> List(\\\"the\\\",\\\"elephant\\\"), 'Obj -> List(\\\"the\\\",\\\"elephant\\\",'PP)\\n) \\nfilterNonTerminals(ambCFG.N,cyk(toCNF(ambCFG), Vector(\\\"He\\\", \\\"shot\\\", \\\"the\\\", \\\"elephant\\\", \\\"in\\\", \\\"his\\\", \\\"pyjamas\\\")).head(0,6)(0)) \"]",
        "hide_output" : "true"
      }
    }
  }, {
    "id" : 33,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nLet us now create an example PCFG. ",
      "extraFields" : { }
    }
  }, {
    "id" : 34,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "implicit def toNonTerm(name:Symbol) = NonTerminal(name)\nimplicit def toTerm(word:String) = Terminal(word)\nval anyToRhs:PartialFunction[Any,RHS] = {\n  case s:String => toTerm(s) \n  case s:Symbol => toNonTerm(s) \n}\nimplicit def toPRule1(rule:(Symbol,(List[Any],Double))) = \n  ProbRule(rule._1,rule._2._1.collect(anyToRhs), rule._2._2) \n\nimplicit def toPRule2(rule:(Symbol,(List[Symbol],Double))) = \n  ProbRule(rule._1,rule._2._1.collect(anyToRhs), rule._2._2) \n\n\nimplicit def toPRule3(rule:(Symbol,(Any,Double))) = \n  ProbRule(rule._1,List(anyToRhs(rule._2._1)),rule._2._2) \n    \nimplicit def toHTML(pcfg:PCFG) = {\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\n      if (x == pcfg.S) -1 else if (y == pcfg.S) 1 else x.name.toString.compareTo(y.name.toString)\n    }  \n  }      \n  table(pcfg.R.sortBy(_.lhs).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\" \"),r.prob)))    \n}\ndef pcfgFromRules(start:NonTerminal, rules:ProbRule*) = {\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\n  PCFG(nonTerminals,terminals,rules.toList,start)\n} \n\n@scala.annotation.tailrec\ndef toPCNF(cfg:PCFG, result:PCFG = PCFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):PCFG = {\n  cfg.R match {\n    case ProbRule(lhs,rhs,p) :: tail if (rhs.length > 2) =>\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\n      val rule1 = ProbRule(lhs, leftN :: rhs.drop(2),p)\n      val rule2 = ProbRule(leftN, rhs.take(2),1.0)\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\n    case ProbRule(lhs, (l1:Terminal) :: l2 :: Nil,p) :: tail => \n      val n = NonTerminal(Symbol(l1.name + id))\n      val rule1 = ProbRule(lhs, n :: l2 :: Nil, p)\n      val rule2 = ProbRule(n,l1 :: Nil, 1.0)\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\n    case ProbRule(lhs,l1 :: (l2:Terminal) :: Nil, p) :: tail => \n      val n = NonTerminal(Symbol(l2.name + id))\n      val rule1 = ProbRule(lhs, l1 :: n :: Nil, p)\n      val rule2 = ProbRule(n, l2 :: Nil, 1.0)\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\n    case h :: tail => toPCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\n    case Nil => result  \n  }    \n} \n",
      "extraFields" : {
        "hide" : "true",
        "hide_output" : "true",
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\\n   case _ => List(tree)\\n} \\ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head\",\"bottomUpParse(cfg, List(\\\"MCRiedel\\\", \\\"raps\\\", \\\"are\\\", \\\"silly\\\")).reverse     \",\"@scala.annotation.tailrec\\ndef toCNF(cfg:CFG, result:CFG = CFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):CFG = {\\n  cfg.R match {\\n    case Rule(lhs,rhs) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = Rule(lhs, leftN :: rhs.drop(2))\\n      val rule2 = Rule(leftN, rhs.take(2))\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs, (l1:Terminal) :: l2 :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = Rule(lhs, n :: l2 :: Nil)\\n      val rule2 = Rule(n,l1 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs,l1 :: (l2:Terminal) :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = Rule(lhs, l1 :: n :: Nil)\\n      val rule2 = Rule(n, l2 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\nval cnf = toCNF(cfg) \",\"type Chart = Map[(Int,Int),List[ParseTree]]\\ndef cyk(cfg:CFG, s:IndexedSeq[String]) = {\\n  var chart:Chart = Map.empty withDefaultValue Nil\\n  var charts:List[Chart] = Nil\\n  val n = s.length\\n  //init\\n  for (i <- 0 until n) {\\n    chart +=  (i,i) -> cfg.R.collect { \\n        case Rule(rhs,(t@Terminal(w)) :: Nil) if w == s(i) => Node(rhs, Leaf(t) :: Nil)}\\n    charts ::= chart  \\n  }\\n  for (l <- 1 until n; b <- 0 until n - l; e = b + l; m <- b until e) {\\n    val trees = for (left@Node(nl,_) <- chart(b,m); \\n                     right@Node(nr,_) <- chart(m + 1,e);\\n                     rule <- cfg.R.filter(_.rhs == nl :: nr :: Nil)) yield {\\n      Node(rule.lhs, left :: right :: Nil)      \\n    } \\n    chart += (b,e) -> (trees ::: chart(b,e))\\n    charts ::= chart\\n  }\\n  charts\\n}\\n\",\"cyk(cnf, Vector(\\\"Matko\\\",\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\")).head(0,3).head \",\"val ambCFG = cfgFromRules('S,\\n  'S -> List('Subj,'VP),\\n  'Subj -> \\\"He\\\",\\n  'Verb -> \\\"shot\\\",\\n  'VP -> List('Verb,'Obj), 'VP -> List('Verb,'Obj,'PP),\\n  'PP -> List(\\\"in\\\",\\\"his\\\",\\\"pyjamas\\\"),\\n  'Obj -> List(\\\"the\\\",\\\"elephant\\\"), 'Obj -> List(\\\"the\\\",\\\"elephant\\\",'PP)\\n) \\nfilterNonTerminals(ambCFG.N,cyk(toCNF(ambCFG), Vector(\\\"He\\\", \\\"shot\\\", \\\"the\\\", \\\"elephant\\\", \\\"in\\\", \\\"his\\\", \\\"pyjamas\\\")).head(0,6)(0)) \",\"case class ProbRule(lhs:NonTerminal, rhs: List[RHS],prob:Double)\\ncase class PCFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[ProbRule],S:NonTerminal)\"]"
      }
    }
  }, {
    "id" : 35,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val pcfg = pcfgFromRules('S,\n  'S -> (List('Subj,'VP), 1.0),\n  'Subj -> (\"He\", 1.0),\n  'Verb -> (\"shot\", 1.0),\n  'VP -> (List('Verb,'Obj), 0.7) , 'VP -> (List('Verb,'Obj,'PP), 0.3),\n  'PP -> (List(\"in\",\"his\",\"pyjamas\"), 1.0),\n  'Obj -> (List(\"the\",\"elephant\"), 0.5), 'Obj -> (List(\"the\",\"elephant\",'PP), 0.5)\n) \npcfg",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\\n   case _ => List(tree)\\n} \\ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head\",\"bottomUpParse(cfg, List(\\\"MCRiedel\\\", \\\"raps\\\", \\\"are\\\", \\\"silly\\\")).reverse     \",\"@scala.annotation.tailrec\\ndef toCNF(cfg:CFG, result:CFG = CFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):CFG = {\\n  cfg.R match {\\n    case Rule(lhs,rhs) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = Rule(lhs, leftN :: rhs.drop(2))\\n      val rule2 = Rule(leftN, rhs.take(2))\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs, (l1:Terminal) :: l2 :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = Rule(lhs, n :: l2 :: Nil)\\n      val rule2 = Rule(n,l1 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs,l1 :: (l2:Terminal) :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = Rule(lhs, l1 :: n :: Nil)\\n      val rule2 = Rule(n, l2 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\nval cnf = toCNF(cfg) \",\"type Chart = Map[(Int,Int),List[ParseTree]]\\ndef cyk(cfg:CFG, s:IndexedSeq[String]) = {\\n  var chart:Chart = Map.empty withDefaultValue Nil\\n  var charts:List[Chart] = Nil\\n  val n = s.length\\n  //init\\n  for (i <- 0 until n) {\\n    chart +=  (i,i) -> cfg.R.collect { \\n        case Rule(rhs,(t@Terminal(w)) :: Nil) if w == s(i) => Node(rhs, Leaf(t) :: Nil)}\\n    charts ::= chart  \\n  }\\n  for (l <- 1 until n; b <- 0 until n - l; e = b + l; m <- b until e) {\\n    val trees = for (left@Node(nl,_) <- chart(b,m); \\n                     right@Node(nr,_) <- chart(m + 1,e);\\n                     rule <- cfg.R.filter(_.rhs == nl :: nr :: Nil)) yield {\\n      Node(rule.lhs, left :: right :: Nil)      \\n    } \\n    chart += (b,e) -> (trees ::: chart(b,e))\\n    charts ::= chart\\n  }\\n  charts\\n}\\n\",\"cyk(cnf, Vector(\\\"Matko\\\",\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\")).head(0,3).head \",\"val ambCFG = cfgFromRules('S,\\n  'S -> List('Subj,'VP),\\n  'Subj -> \\\"He\\\",\\n  'Verb -> \\\"shot\\\",\\n  'VP -> List('Verb,'Obj), 'VP -> List('Verb,'Obj,'PP),\\n  'PP -> List(\\\"in\\\",\\\"his\\\",\\\"pyjamas\\\"),\\n  'Obj -> List(\\\"the\\\",\\\"elephant\\\"), 'Obj -> List(\\\"the\\\",\\\"elephant\\\",'PP)\\n) \\nfilterNonTerminals(ambCFG.N,cyk(toCNF(ambCFG), Vector(\\\"He\\\", \\\"shot\\\", \\\"the\\\", \\\"elephant\\\", \\\"in\\\", \\\"his\\\", \\\"pyjamas\\\")).head(0,6)(0)) \",\"case class ProbRule(lhs:NonTerminal, rhs: List[RHS],prob:Double)\\ncase class PCFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[ProbRule],S:NonTerminal)\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toPRule1(rule:(Symbol,(List[Any],Double))) = \\n  ProbRule(rule._1,rule._2._1.collect(anyToRhs), rule._2._2) \\n\\nimplicit def toPRule2(rule:(Symbol,(List[Symbol],Double))) = \\n  ProbRule(rule._1,rule._2._1.collect(anyToRhs), rule._2._2) \\n\\n\\nimplicit def toPRule3(rule:(Symbol,(Any,Double))) = \\n  ProbRule(rule._1,List(anyToRhs(rule._2._1)),rule._2._2) \\n    \\nimplicit def toHTML(pcfg:PCFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == pcfg.S) -1 else if (y == pcfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(pcfg.R.sortBy(_.lhs).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"),r.prob)))    \\n}\\ndef pcfgFromRules(start:NonTerminal, rules:ProbRule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  PCFG(nonTerminals,terminals,rules.toList,start)\\n} \\n\\n@scala.annotation.tailrec\\ndef toPCNF(cfg:PCFG, result:PCFG = PCFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):PCFG = {\\n  cfg.R match {\\n    case ProbRule(lhs,rhs,p) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = ProbRule(lhs, leftN :: rhs.drop(2),p)\\n      val rule2 = ProbRule(leftN, rhs.take(2),1.0)\\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case ProbRule(lhs, (l1:Terminal) :: l2 :: Nil,p) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = ProbRule(lhs, n :: l2 :: Nil, p)\\n      val rule2 = ProbRule(n,l1 :: Nil, 1.0)\\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case ProbRule(lhs,l1 :: (l2:Terminal) :: Nil, p) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = ProbRule(lhs, l1 :: n :: Nil, p)\\n      val rule2 = ProbRule(n, l2 :: Nil, 1.0)\\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toPCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\n\"]",
        "hide_output" : "false"
      }
    }
  }, {
    "id" : 36,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nLet us first focus on the prediction task: given a sentence, find the highest scoring parse tree. In a way, we have already solved a variant of this problem. We can consider a CFG as a deterministic distribution over trees, and finding _a_ highest scoring parse is equivalent to finding any legal tree&mdash;our bottom-up and dynamic program based algorithms hence performed a structured prediction.\n\n<div class=\"newslide\"></div>\n#### CYK for PCFGs\nHere we present a probabilistic variant of the CYK algorithm. Notice that again we require normalization to CNF. Exercise: how to incorporate the rule probabilities during normalization? \n",
      "extraFields" : { }
    }
  }, {
    "id" : 37,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "type PChart = Map[(Int,Int),List[(ParseTree,Double)]]\ndef pcyk(cfg:PCFG, s:IndexedSeq[String]) = {\n  var chart:PChart = Map.empty withDefaultValue Nil\n  var charts:List[PChart] = Nil\n  val n = s.length\n  def unify(trees:List[(ParseTree,Double)]) = \n    trees.groupBy(_._1.node).mapValues(_.maxBy(_._2)).values.toList\n  //init\n  for (i <- 0 until n) {\n    chart +=  (i,i) -> unify(cfg.R.collect { \n        case ProbRule(rhs,(t@Terminal(w)) :: Nil, p) if w == s(i) => (Node(rhs, Leaf(t) :: Nil), math.log(p))})\n    charts ::= chart  \n  }\n  for (l <- 1 until n; b <- 0 until n - l; e = b + l; m <- b until e) {\n    val trees = for ((left@Node(nl,_),pl) <- chart(b,m); \n                     (right@Node(nr,_),pr) <- chart(m + 1,e);\n                     rule <- cfg.R.filter(_.rhs == nl :: nr :: Nil)) yield {\n      (Node(rule.lhs, left :: right :: Nil), pl + pr + math.log(rule.prob))      \n    } \n    chart += (b,e) -> unify((trees ::: chart(b,e)))\n    charts ::= chart\n  }\n  charts\n}\n",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\\n   case _ => List(tree)\\n} \\ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head\",\"bottomUpParse(cfg, List(\\\"MCRiedel\\\", \\\"raps\\\", \\\"are\\\", \\\"silly\\\")).reverse     \",\"@scala.annotation.tailrec\\ndef toCNF(cfg:CFG, result:CFG = CFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):CFG = {\\n  cfg.R match {\\n    case Rule(lhs,rhs) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = Rule(lhs, leftN :: rhs.drop(2))\\n      val rule2 = Rule(leftN, rhs.take(2))\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs, (l1:Terminal) :: l2 :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = Rule(lhs, n :: l2 :: Nil)\\n      val rule2 = Rule(n,l1 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs,l1 :: (l2:Terminal) :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = Rule(lhs, l1 :: n :: Nil)\\n      val rule2 = Rule(n, l2 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\nval cnf = toCNF(cfg) \",\"type Chart = Map[(Int,Int),List[ParseTree]]\\ndef cyk(cfg:CFG, s:IndexedSeq[String]) = {\\n  var chart:Chart = Map.empty withDefaultValue Nil\\n  var charts:List[Chart] = Nil\\n  val n = s.length\\n  //init\\n  for (i <- 0 until n) {\\n    chart +=  (i,i) -> cfg.R.collect { \\n        case Rule(rhs,(t@Terminal(w)) :: Nil) if w == s(i) => Node(rhs, Leaf(t) :: Nil)}\\n    charts ::= chart  \\n  }\\n  for (l <- 1 until n; b <- 0 until n - l; e = b + l; m <- b until e) {\\n    val trees = for (left@Node(nl,_) <- chart(b,m); \\n                     right@Node(nr,_) <- chart(m + 1,e);\\n                     rule <- cfg.R.filter(_.rhs == nl :: nr :: Nil)) yield {\\n      Node(rule.lhs, left :: right :: Nil)      \\n    } \\n    chart += (b,e) -> (trees ::: chart(b,e))\\n    charts ::= chart\\n  }\\n  charts\\n}\\n\",\"cyk(cnf, Vector(\\\"Matko\\\",\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\")).head(0,3).head \",\"val ambCFG = cfgFromRules('S,\\n  'S -> List('Subj,'VP),\\n  'Subj -> \\\"He\\\",\\n  'Verb -> \\\"shot\\\",\\n  'VP -> List('Verb,'Obj), 'VP -> List('Verb,'Obj,'PP),\\n  'PP -> List(\\\"in\\\",\\\"his\\\",\\\"pyjamas\\\"),\\n  'Obj -> List(\\\"the\\\",\\\"elephant\\\"), 'Obj -> List(\\\"the\\\",\\\"elephant\\\",'PP)\\n) \\nfilterNonTerminals(ambCFG.N,cyk(toCNF(ambCFG), Vector(\\\"He\\\", \\\"shot\\\", \\\"the\\\", \\\"elephant\\\", \\\"in\\\", \\\"his\\\", \\\"pyjamas\\\")).head(0,6)(0)) \",\"case class ProbRule(lhs:NonTerminal, rhs: List[RHS],prob:Double)\\ncase class PCFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[ProbRule],S:NonTerminal)\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toPRule1(rule:(Symbol,(List[Any],Double))) = \\n  ProbRule(rule._1,rule._2._1.collect(anyToRhs), rule._2._2) \\n\\nimplicit def toPRule2(rule:(Symbol,(List[Symbol],Double))) = \\n  ProbRule(rule._1,rule._2._1.collect(anyToRhs), rule._2._2) \\n\\n\\nimplicit def toPRule3(rule:(Symbol,(Any,Double))) = \\n  ProbRule(rule._1,List(anyToRhs(rule._2._1)),rule._2._2) \\n    \\nimplicit def toHTML(pcfg:PCFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == pcfg.S) -1 else if (y == pcfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(pcfg.R.sortBy(_.lhs).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"),r.prob)))    \\n}\\ndef pcfgFromRules(start:NonTerminal, rules:ProbRule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  PCFG(nonTerminals,terminals,rules.toList,start)\\n} \\n\\n@scala.annotation.tailrec\\ndef toPCNF(cfg:PCFG, result:PCFG = PCFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):PCFG = {\\n  cfg.R match {\\n    case ProbRule(lhs,rhs,p) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = ProbRule(lhs, leftN :: rhs.drop(2),p)\\n      val rule2 = ProbRule(leftN, rhs.take(2),1.0)\\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case ProbRule(lhs, (l1:Terminal) :: l2 :: Nil,p) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = ProbRule(lhs, n :: l2 :: Nil, p)\\n      val rule2 = ProbRule(n,l1 :: Nil, 1.0)\\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case ProbRule(lhs,l1 :: (l2:Terminal) :: Nil, p) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = ProbRule(lhs, l1 :: n :: Nil, p)\\n      val rule2 = ProbRule(n, l2 :: Nil, 1.0)\\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toPCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\n\",\"val pcfg = pcfgFromRules('S,\\n  'S -> (List('Subj,'VP), 1.0),\\n  'Subj -> (\\\"He\\\", 1.0),\\n  'Verb -> (\\\"shot\\\", 1.0),\\n  'VP -> (List('Verb,'Obj), 0.7) , 'VP -> (List('Verb,'Obj,'PP), 0.3),\\n  'PP -> (List(\\\"in\\\",\\\"his\\\",\\\"pyjamas\\\"), 1.0),\\n  'Obj -> (List(\\\"the\\\",\\\"elephant\\\"), 0.5), 'Obj -> (List(\\\"the\\\",\\\"elephant\\\",'PP), 0.5)\\n) \\npcfg\"]",
        "hide_output" : "true"
      }
    }
  }, {
    "id" : 38,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "<div class=\"newslide\"></div>\nWe now have a higher probability associated to the preferred parse.",
      "extraFields" : { }
    }
  }, {
    "id" : 39,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "filterNonTerminals(pcfg.N, pcyk(toPCNF(pcfg), Vector(\"He\", \"shot\", \"the\", \"elephant\", \"in\", \"his\", \"pyjamas\")).head(0,6)(0)._1)",
      "extraFields" : {
        "aggregatedCells" : "[\"sealed trait RHS\\ncase class NonTerminal(name:Symbol) extends RHS \\ncase class Terminal(name:String) extends RHS \\ncase class Rule(lhs:NonTerminal,rhs:List[RHS])\\ncase class CFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[Rule],S:NonTerminal)\\n1\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toRule1(rule:(Symbol,List[Any])) = \\n  Rule(rule._1,rule._2.collect(anyToRhs)) \\n\\nimplicit def toRule2(rule:(Symbol,Any)) = \\n  Rule(rule._1,List(anyToRhs(rule._2))) \\n    \\ndef rhsToString(rhs:RHS) = rhs match {\\n  case NonTerminal(n) => n.toString\\n  case Terminal(w) => w\\n}    \\nimplicit def toHTML(cfg:CFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == cfg.S) -1 else if (y == cfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(cfg.R.sortBy(_.lhs)(lhsOrdering).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\nimplicit def derivToHTML(deriv:Seq[Seq[RHS]]) = {\\n  table(deriv.map(d => Seq(d.map(rhsToString).mkString(\\\" \\\"))))    \\n}\\ndef cfgFromRules(start:NonTerminal, rules:Rule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  CFG(nonTerminals,terminals,rules.toList,start)\\n}  \",\"val cfg = cfgFromRules('S,\\n  'S -> List('NP_p,'VP_p), 'S -> List('NP_s, 'VP_s),   \\n  'NP_p -> List(\\\"Matko\\\",\\\"raps\\\"),\\n  'VP_p -> List(\\\"are\\\", 'ADJ),\\n  'NP_s -> List(\\\"Matko\\\"),\\n  'VP_s -> List(\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\"),\\n  'ADJ -> \\\"silly\\\")\\ncfg \",\"import scala.collection.mutable.{ArrayBuffer,ListBuffer}\\nval rand = new scala.util.Random(0) \\n@scala.annotation.tailrec\\ndef generateDeriv(cfg: CFG, sentence:Seq[RHS], result:Seq[Seq[RHS]] = Seq.empty):Seq[Seq[RHS]] = \\n  sentence.zipWithIndex.collectFirst { case r@(n:NonTerminal,_) => r } match {\\n    case Some((n,index)) =>\\n      val rules =  cfg.R.filter(_.lhs == n)\\n      val sampled = rules(rand.nextInt(rules.length))\\n      val next = sentence.patch(index,sampled.rhs,1) \\n      generateDeriv(cfg, next, result.get :+ next)\\n    case None => result \\n  }\",\"generateDeriv(cfg,Seq(cfg.S)) \",\"sealed trait ParseTree { def node: RHS}\\ncase class Node(node:NonTerminal, children:List[ParseTree]) extends ParseTree\\ncase class Leaf(node:Terminal) extends ParseTree\",\"import ml.wolfe.nlp.syntax._\\ndef toRenderTree(tree:ParseTree):RenderTree = tree match {\\n  case Leaf(Terminal(w)) => RenderTree(w,\\\"terminal\\\")\\n  case Node(NonTerminal(l),children) => RenderTree(l.toString, \\\"nonterminal\\\",children map toRenderTree)\\n}\\nimplicit def treeToHTML(tree:ParseTree) = renderParseTree(toRenderTree(tree))\\n\",\"Node('S, List(Node('NP_p, List(Leaf(\\\"Matko\\\"), Leaf(\\\"raps\\\"))),\\n              Node('VP_p,List(Leaf(\\\"are\\\"), Leaf(\\\"silly\\\")))))\",\"def generateTree(cfg:CFG, rhs:RHS):ParseTree = rhs match {\\n  case t:Terminal => Leaf(t)\\n  case n:NonTerminal =>\\n    val rules =  cfg.R.filter(_.lhs == n)\\n    val sampled = rules(rand.nextInt(rules.length))\\n    val children = sampled.rhs.map(generateTree(cfg,_))\\n    Node(n,children)\\n} \",\"generateTree(cfg,'S)     \",\"type Stack = List[ParseTree]\\ntype Buffer = List[String]\\ncase class State(stack:Stack, buffer:Buffer, rules:List[Rule])\\ncase class Transition(state:State, op:Symbol)\\n\\ndef bottomUpParse(cfg:CFG, sentence:List[String]) = {\\n  var history:List[State] = Nil\\n  var state = State(Nil,sentence,Nil)\\n  var transitions = Transition(state,'Init) :: Nil\\n  def reduce() {\\n    while (state.rules.nonEmpty) {\\n      val rule = state.rules.head\\n      val top = state.stack.take(rule.rhs.length).reverse\\n      if (top.map(_.node) == rule.rhs) {\\n        history = state :: history \\n        state = state.copy(\\n          stack = Node(rule.lhs, top) :: state.stack.drop(rule.rhs.length),\\n          rules = cfg.R\\n        )\\n        transitions = Transition(state,'Reduce) :: transitions\\n\\n      } else state = state.copy(rules = state.rules.tail)\\n    }   \\n  }\\n  def shift() {\\n    state = state.copy(\\n      stack = Leaf(state.buffer.head) :: state.stack,  \\n      buffer = state.buffer.tail, \\n      rules = cfg.R\\n    )\\n    transitions = Transition(state,'Shift) :: transitions\\n  }\\n  def backtrack() {\\n    state = history.head.copy(rules = history.head.rules.tail) \\n    transitions = Transition(state,'Backtrack) :: transitions\\n    history = history.tail\\n  }\\n  while (state.buffer.nonEmpty || (state.stack.length > 1 && history.nonEmpty) || state.rules.nonEmpty) {\\n    if (state.rules.nonEmpty) reduce()\\n    if (state.buffer.nonEmpty) shift() \\n    else if (state.stack.length > 1) backtrack()\\n  }\\n  transitions \\n} \",\"def treeToString(tree:ParseTree):String = tree match {\\n  case Node(NonTerminal(n), children) => s\\\"($n ${children.map(treeToString).mkString(\\\" \\\")})\\\"\\n  case Leaf(Terminal(w)) => w\\n}\\nimplicit def transitionsToHTML(transitions:List[Transition]) = {\\n  def toRow(t:Transition) = Seq(t.op, t.state.stack.reverse.map(treeToString).mkString(\\\" | \\\"),t.state.buffer.mkString(\\\" \\\"))\\n  table(transitions.map(toRow))\\n}\\ndef filterNonTerminalsRecursive(N:Set[NonTerminal])(tree: ParseTree):List[ParseTree] = tree match {\\n   case Node(n, children) if !N(n) => children flatMap filterNonTerminalsRecursive(N)\\n   case Node(n, children) => Node(n,children flatMap filterNonTerminalsRecursive(N))::Nil\\n   case _ => List(tree)\\n} \\ndef filterNonTerminals(N:Set[NonTerminal], tree: ParseTree) = filterNonTerminalsRecursive(N)(tree).head\",\"bottomUpParse(cfg, List(\\\"MCRiedel\\\", \\\"raps\\\", \\\"are\\\", \\\"silly\\\")).reverse     \",\"@scala.annotation.tailrec\\ndef toCNF(cfg:CFG, result:CFG = CFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):CFG = {\\n  cfg.R match {\\n    case Rule(lhs,rhs) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = Rule(lhs, leftN :: rhs.drop(2))\\n      val rule2 = Rule(leftN, rhs.take(2))\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs, (l1:Terminal) :: l2 :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = Rule(lhs, n :: l2 :: Nil)\\n      val rule2 = Rule(n,l1 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case Rule(lhs,l1 :: (l2:Terminal) :: Nil) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = Rule(lhs, l1 :: n :: Nil)\\n      val rule2 = Rule(n, l2 :: Nil)\\n      toCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\nval cnf = toCNF(cfg) \",\"type Chart = Map[(Int,Int),List[ParseTree]]\\ndef cyk(cfg:CFG, s:IndexedSeq[String]) = {\\n  var chart:Chart = Map.empty withDefaultValue Nil\\n  var charts:List[Chart] = Nil\\n  val n = s.length\\n  //init\\n  for (i <- 0 until n) {\\n    chart +=  (i,i) -> cfg.R.collect { \\n        case Rule(rhs,(t@Terminal(w)) :: Nil) if w == s(i) => Node(rhs, Leaf(t) :: Nil)}\\n    charts ::= chart  \\n  }\\n  for (l <- 1 until n; b <- 0 until n - l; e = b + l; m <- b until e) {\\n    val trees = for (left@Node(nl,_) <- chart(b,m); \\n                     right@Node(nr,_) <- chart(m + 1,e);\\n                     rule <- cfg.R.filter(_.rhs == nl :: nr :: Nil)) yield {\\n      Node(rule.lhs, left :: right :: Nil)      \\n    } \\n    chart += (b,e) -> (trees ::: chart(b,e))\\n    charts ::= chart\\n  }\\n  charts\\n}\\n\",\"cyk(cnf, Vector(\\\"Matko\\\",\\\"raps\\\", \\\"in\\\", \\\"StatNLP\\\")).head(0,3).head \",\"val ambCFG = cfgFromRules('S,\\n  'S -> List('Subj,'VP),\\n  'Subj -> \\\"He\\\",\\n  'Verb -> \\\"shot\\\",\\n  'VP -> List('Verb,'Obj), 'VP -> List('Verb,'Obj,'PP),\\n  'PP -> List(\\\"in\\\",\\\"his\\\",\\\"pyjamas\\\"),\\n  'Obj -> List(\\\"the\\\",\\\"elephant\\\"), 'Obj -> List(\\\"the\\\",\\\"elephant\\\",'PP)\\n) \\nfilterNonTerminals(ambCFG.N,cyk(toCNF(ambCFG), Vector(\\\"He\\\", \\\"shot\\\", \\\"the\\\", \\\"elephant\\\", \\\"in\\\", \\\"his\\\", \\\"pyjamas\\\")).head(0,6)(0)) \",\"case class ProbRule(lhs:NonTerminal, rhs: List[RHS],prob:Double)\\ncase class PCFG(N:Set[NonTerminal],Sigma:Set[Terminal],R:List[ProbRule],S:NonTerminal)\",\"implicit def toNonTerm(name:Symbol) = NonTerminal(name)\\nimplicit def toTerm(word:String) = Terminal(word)\\nval anyToRhs:PartialFunction[Any,RHS] = {\\n  case s:String => toTerm(s) \\n  case s:Symbol => toNonTerm(s) \\n}\\nimplicit def toPRule1(rule:(Symbol,(List[Any],Double))) = \\n  ProbRule(rule._1,rule._2._1.collect(anyToRhs), rule._2._2) \\n\\nimplicit def toPRule2(rule:(Symbol,(List[Symbol],Double))) = \\n  ProbRule(rule._1,rule._2._1.collect(anyToRhs), rule._2._2) \\n\\n\\nimplicit def toPRule3(rule:(Symbol,(Any,Double))) = \\n  ProbRule(rule._1,List(anyToRhs(rule._2._1)),rule._2._2) \\n    \\nimplicit def toHTML(pcfg:PCFG) = {\\n  implicit val lhsOrdering = new Ordering[NonTerminal] {\\n    override def compare(x: NonTerminal, y: NonTerminal): Int = {\\n      if (x == pcfg.S) -1 else if (y == pcfg.S) 1 else x.name.toString.compareTo(y.name.toString)\\n    }  \\n  }      \\n  table(pcfg.R.sortBy(_.lhs).map(r => Seq(r.lhs.name,r.rhs.map(rhsToString).mkString(\\\" \\\"),r.prob)))    \\n}\\ndef pcfgFromRules(start:NonTerminal, rules:ProbRule*) = {\\n  val terminals = rules.flatMap(_.rhs).collect{ case n:Terminal => n}.toSet\\n  val nonTerminals = (rules.flatMap(r => r.lhs :: r.rhs)).collect{ case n:NonTerminal => n}.toSet\\n  PCFG(nonTerminals,terminals,rules.toList,start)\\n} \\n\\n@scala.annotation.tailrec\\ndef toPCNF(cfg:PCFG, result:PCFG = PCFG(Set.empty, Set.empty, Nil,'S), id:Int = 0):PCFG = {\\n  cfg.R match {\\n    case ProbRule(lhs,rhs,p) :: tail if (rhs.length > 2) =>\\n      val leftN = NonTerminal(Symbol(lhs.name.toString + id))\\n      val rule1 = ProbRule(lhs, leftN :: rhs.drop(2),p)\\n      val rule2 = ProbRule(leftN, rhs.take(2),1.0)\\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case ProbRule(lhs, (l1:Terminal) :: l2 :: Nil,p) :: tail => \\n      val n = NonTerminal(Symbol(l1.name + id))\\n      val rule1 = ProbRule(lhs, n :: l2 :: Nil, p)\\n      val rule2 = ProbRule(n,l1 :: Nil, 1.0)\\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case ProbRule(lhs,l1 :: (l2:Terminal) :: Nil, p) :: tail => \\n      val n = NonTerminal(Symbol(l2.name + id))\\n      val rule1 = ProbRule(lhs, l1 :: n :: Nil, p)\\n      val rule2 = ProbRule(n, l2 :: Nil, 1.0)\\n      toPCNF(cfg.copy(R = rule1::rule2::tail), result, id + 1)\\n    case h :: tail => toPCNF(cfg.copy(R = tail), result.copy(R = h :: result.R),id)\\n    case Nil => result  \\n  }    \\n} \\n\",\"val pcfg = pcfgFromRules('S,\\n  'S -> (List('Subj,'VP), 1.0),\\n  'Subj -> (\\\"He\\\", 1.0),\\n  'Verb -> (\\\"shot\\\", 1.0),\\n  'VP -> (List('Verb,'Obj), 0.7) , 'VP -> (List('Verb,'Obj,'PP), 0.3),\\n  'PP -> (List(\\\"in\\\",\\\"his\\\",\\\"pyjamas\\\"), 1.0),\\n  'Obj -> (List(\\\"the\\\",\\\"elephant\\\"), 0.5), 'Obj -> (List(\\\"the\\\",\\\"elephant\\\",'PP), 0.5)\\n) \\npcfg\",\"type PChart = Map[(Int,Int),List[(ParseTree,Double)]]\\ndef pcyk(cfg:PCFG, s:IndexedSeq[String]) = {\\n  var chart:PChart = Map.empty withDefaultValue Nil\\n  var charts:List[PChart] = Nil\\n  val n = s.length\\n  def unify(trees:List[(ParseTree,Double)]) = \\n    trees.groupBy(_._1.node).mapValues(_.maxBy(_._2)).values.toList\\n  //init\\n  for (i <- 0 until n) {\\n    chart +=  (i,i) -> unify(cfg.R.collect { \\n        case ProbRule(rhs,(t@Terminal(w)) :: Nil, p) if w == s(i) => (Node(rhs, Leaf(t) :: Nil), math.log(p))})\\n    charts ::= chart  \\n  }\\n  for (l <- 1 until n; b <- 0 until n - l; e = b + l; m <- b until e) {\\n    val trees = for ((left@Node(nl,_),pl) <- chart(b,m); \\n                     (right@Node(nr,_),pr) <- chart(m + 1,e);\\n                     rule <- cfg.R.filter(_.rhs == nl :: nr :: Nil)) yield {\\n      (Node(rule.lhs, left :: right :: Nil), pl + pr + math.log(rule.prob))      \\n    } \\n    chart += (b,e) -> unify((trees ::: chart(b,e)))\\n    charts ::= chart\\n  }\\n  charts\\n}\\n\"]"
      }
    }
  } ],
  "config" : { }
}
